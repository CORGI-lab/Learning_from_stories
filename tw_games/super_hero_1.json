{"version": 1, "world": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "oven_0", "type": "oven"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "pr_0", "type": "pr"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "rbr_0", "type": "rbr"}, {"name": "r_3", "type": "r"}]}, {"name": "at", "arguments": [{"name": "s_0", "type": "s"}, {"name": "r_1", "type": "r"}]}, {"name": "east_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "east_of", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_4", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "not_asked", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "not_stopped", "arguments": [{"name": "rbr_0", "type": "rbr"}]}, {"name": "on", "arguments": [{"name": "f_0", "type": "f"}, {"name": "s_0", "type": "s"}]}, {"name": "raw", "arguments": [{"name": "f_0", "type": "f"}]}, {"name": "south_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "south_of", "arguments": [{"name": "r_4", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}], "grammar": {"theme": "house", "names_to_exclude": [], "include_adj": false, "blend_descriptions": true, "ambiguous_instructions": false, "only_last_action": true, "blend_instructions": true, "allowed_variables_numbering": false, "unique_expansion": false}, "quests": [{"desc": "", "reward": 2, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "asked", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "stopped", "arguments": [{"name": "rbr_0", "type": "rbr"}]}], "postconditions": [{"name": "asked", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "stopped", "arguments": [{"name": "rbr_0", "type": "rbr"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_0", "type": "f"}, {"name": "oven_0", "type": "oven"}, {"name": "r_1", "type": "r"}]}]}}], "fail_events": []}, {"desc": "", "reward": 2, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "asked", "arguments": [{"name": "pr_0", "type": "pr"}]}], "postconditions": [{"name": "asked", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_0", "type": "f"}, {"name": "oven_0", "type": "oven"}, {"name": "r_1", "type": "r"}]}]}}], "fail_events": []}, {"desc": "", "reward": 0, "commands": [], "win_events": [], "fail_events": [{"commands": ["go east", "go south"], "actions": [{"name": "go/east", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}]}, {"name": "go/south", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_4", "type": "r"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_4", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_4", "type": "r"}]}]}], "condition": {"name": "trigger", "preconditions": [{"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_4", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_4", "type": "r"}]}], "postconditions": [{"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_4", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_4", "type": "r"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_0", "type": "f"}, {"name": "oven_0", "type": "oven"}, {"name": "r_1", "type": "r"}]}]}}]}, {"desc": "", "reward": 0, "commands": [], "win_events": [], "fail_events": [{"commands": ["go east", "go east"], "actions": [{"name": "go/east", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}]}, {"name": "go/east", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}]}], "condition": {"name": "trigger", "preconditions": [{"name": "west_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_0", "type": "f"}, {"name": "oven_0", "type": "oven"}, {"name": "r_1", "type": "r"}]}]}}]}, {"desc": "", "reward": 0, "commands": [], "win_events": [], "fail_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "not_asked", "arguments": [{"name": "pr_0", "type": "pr"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "not_asked", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_0", "type": "f"}, {"name": "oven_0", "type": "oven"}, {"name": "r_1", "type": "r"}]}]}}]}], "infos": [["P", {"id": "P", "type": "P", "name": null, "noun": null, "adj": null, "desc": null, "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["I", {"id": "I", "type": "I", "name": null, "noun": null, "adj": null, "desc": null, "room_type": null, "definite": null, "indefinite": null, "synonyms": null}], ["r_1", {"id": "r_1", "type": "r", "name": "Alley", "noun": null, "adj": null, "desc": "There is a person beside the table in the alley. You can find an oven here as well.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["r_0", {"id": "r_0", "type": "r", "name": "Room A", "noun": null, "adj": null, "desc": "You are in a road. Some mobs are planning to rob a bank. You need to stop them. Go east to the alley. You can find a person in the alley who has information about the roberry. Collect information from him and prevent the roberry.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["r_2", {"id": "r_2", "type": "r", "name": "Bank1", "noun": null, "adj": null, "desc": "You are in a Bank1. An usual kind of place. The room seems oddly familiar, as though it were only superficially different from the other rooms in the building.\n\n\n\nThere is an exit to the west. Don't worry, there is no door.", "room_type": "storage", "definite": null, "indefinite": null, "synonyms": null}], ["r_3", {"id": "r_3", "type": "r", "name": "Bank2", "noun": null, "adj": null, "desc": "Well I'll be, you are in a place we're calling a Bank2.\n\n\n\nThere is an exit to the south.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["r_4", {"id": "r_4", "type": "r", "name": "Bank3", "noun": null, "adj": null, "desc": "Okay, so you're in a Bank3, cool, but is it ordinary? You better believe it is.\n\n\n\nYou don't like doors? Why not try going north, that entranceway is not blocked by one.", "room_type": "work", "definite": null, "indefinite": null, "synonyms": null}], ["oven_0", {"id": "oven_0", "type": "oven", "name": "oven", "noun": null, "adj": null, "desc": "this is an oven. you can cook your food", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["pr_0", {"id": "pr_0", "type": "pr", "name": "informant", "noun": null, "adj": null, "desc": "This person knows about the bank roberry. Do a favor for him. He will help you.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["rbr_0", {"id": "rbr_0", "type": "rbr", "name": "joker", "noun": null, "adj": null, "desc": "", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["s_0", {"id": "s_0", "type": "s", "name": "table", "noun": null, "adj": null, "desc": "It is a metal sturdy table. There are some food on the table", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["f_0", {"id": "f_0", "type": "f", "name": "carrot", "noun": null, "adj": null, "desc": "It's carrot", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}]], "KB": {"logic": "type bbq : t {\n    rules {\n        cook/bbq/raw           :: $at(P, r) & $at(bbq, r) & $in(f, I) & raw(f)                         -> grilled(f) & cooked(f);\n        cook/bbq/burned        :: $at(P, r) & $at(bbq, r) & $in(f, I) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/bbq/needs_cooking :: $at(P, r) & $at(bbq, r) & $in(f, I) & needs_cooking(f) & inedible(f) -> grilled(f) & edible(f) & cooked(f);\n    }\n\n    inform7 {\n        type {\n            kind :: \"bbq-like\";\n            definition :: \"bbq-like is a source of heat. bbq-like are fixed in place.\";\n        }\n\n        predicates {\n            heat_source(bbq) :: \"\";\n            fixed(bbq) :: \"\";\n        }\n\n        commands {\n            cook/bbq/raw           :: \"cook {f} with {bbq}\" :: \"cooking the {f}\";\n            cook/bbq/burned        :: \"cook {f} with {bbq}\" :: \"cooking the {f}\";\n            cook/bbq/needs_cooking :: \"cook {f} with {bbq}\" :: \"cooking the {f}\";\n        }\n    }\n}\n\n# container\ntype c : t {\n    predicates {\n        open(c);\n        closed(c);\n        locked(c);\n\n        in(o, c);\n    }\n\n    rules {\n        lock/c   :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & closed(c) -> locked(c);\n        unlock/c :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & locked(c) -> closed(c);\n\n        open/c  :: $at(P, r) & $at(c, r) & closed(c) -> open(c);\n        close/c :: $at(P, r) & $at(c, r) & open(c) -> closed(c);\n    }\n\n    reverse_rules {\n        lock/c :: unlock/c;\n        open/c :: close/c;\n    }\n\n    constraints {\n        c1 :: open(c)   & closed(c) -> fail();\n        c2 :: open(c)   & locked(c) -> fail();\n        c3 :: closed(c) & locked(c) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"container\";\n            definition :: \"containers are openable, lockable and fixed in place. containers are usually closed.\";\n        }\n\n        predicates {\n            open(c) :: \"The {c} is open\";\n            closed(c) :: \"The {c} is closed\";\n            locked(c) :: \"The {c} is locked\";\n\n            in(o, c) :: \"The {o} is in the {c}\";\n            holder(c) :: \"\";\n            openable(c) :: \"\";\n            closeable(c) :: \"\";\n            lockable(c) :: \"\";\n            unlockable(c) :: \"\";\n            fixed(c) :: \"\";\n        }\n\n        commands {\n            open/c :: \"open {c}\" :: \"opening the {c}\";\n            close/c :: \"close {c}\" :: \"closing the {c}\";\n\n            lock/c :: \"lock {c} with {k}\" :: \"locking the {c} with the {k}\";\n            unlock/c :: \"unlock {c} with {k}\" :: \"unlocking the {c} with the {k}\";\n        }\n\n        code :: \"\"\"\n            After examining an open container which contains nothing:\n                say \"It's empty.\".\n        \"\"\";\n    }\n}\n\n# door\ntype d : t {\n    predicates {\n        open(d);\n        closed(d);\n        locked(d);\n\n        link(r, d, r);\n    }\n\n    rules {\n        lock/d   :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & closed(d) -> locked(d);\n        unlock/d :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & locked(d) -> closed(d);\n\n        open/d   :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & closed(d) -> open(d) & free(r, r') & free(r', r);\n        close/d  :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & open(d) & free(r, r') & free(r', r) -> closed(d);\n\n        enter/d :: at(P, r) & $link(r, d, r') -> at(P, r');\n    }\n\n    reverse_rules {\n        lock/d :: unlock/d;\n        open/d :: close/d;\n    }\n\n    constraints {\n        d1 :: open(d)   & closed(d) -> fail();\n        d2 :: open(d)   & locked(d) -> fail();\n        d3 :: closed(d) & locked(d) -> fail();\n\n        # A door can't be used to link more than two rooms.\n        link1 :: link(r, d, r') & link(r, d, r'') -> fail();\n        link2 :: link(r, d, r') & link(r'', d, r''') -> fail();\n\n        # There's already a door linking two rooms.\n        link3 :: link(r, d, r') & link(r, d', r') -> fail();\n\n        # There cannot be more than four doors in a room.\n        dr2 :: link(r, d1: d, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n\n        free1 :: link(r, d, r') & free(r, r') & closed(d) -> fail();\n        free2 :: link(r, d, r') & free(r, r') & locked(d) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"door\";\n            definition :: \"door is openable and lockable.\";\n        }\n\n        predicates {\n            open(d) :: \"The {d} is open\";\n            closed(d) :: \"The {d} is closed\";\n            locked(d) :: \"The {d} is locked\";\n            link(r, d, r') :: \"\";  # No equivalent in Inform7.\n            openable(d) :: \"\";\n            closeable(d) :: \"\";\n            lockable(d) :: \"\";\n            unlockable(d) :: \"\";\n            fixed(d) :: \"\";\n        }\n\n        commands {\n            open/d :: \"open {d}\" :: \"opening {d}\";\n            close/d :: \"close {d}\" :: \"closing {d}\";\n\n            unlock/d :: \"unlock {d} with {k}\" :: \"unlocking {d} with the {k}\";\n            lock/d :: \"lock {d} with {k}\" :: \"locking {d} with the {k}\";\n\n            enter/d :: \"enter {d}\" :: \"entering {d}\";\n        }\n    }\n}\n\n# food\ntype f : o {\n    predicates {\n        consumed(f);\n        edible(f);\n        inedible(f);\n\n        needs_cooking(f);\n        raw(f);\n        cooked(f);\n        burned(f);\n\n        roasted(f);\n        fried(f);\n        grilled(f);\n        # boiled(f);\n        # steamed(f);\n\n        uncut(f);\n        chopped(f);\n        sliced(f);\n        diced(f);\n    }\n\n    rules {\n        eat :: in(f, I) & edible(f) -> consumed(f);\n        drink :: in(f, I) & drinkable(f) -> consumed(f);\n        slice :: $in(f, I) & $in(o, I) & $sharp(o) & uncut(f) -> sliced(f);\n        dice :: $in(f, I) & $in(o, I) & $sharp(o) & uncut(f) -> diced(f);\n        chop :: $in(f, I) & $in(o, I) & $sharp(o) & uncut(f) -> chopped(f);\n    }\n\n    constraints {\n        consumed1 :: consumed(f) & in(f, I) -> fail();\n        consumed2 :: consumed(f) & in(f, c) -> fail();\n        consumed3 :: consumed(f) & on(f, s) -> fail();\n        consumed4 :: consumed(f) & at(f, r) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"food\";\n            definition :: \"food is usually edible. food is cookable. food has a type of cooking. food has a type of cutting. food can be cooked. food can be burned. food can be consumed. food is usually not consumed. food is usually cuttable.\";\n        }\n\n        predicates {\n            edible(f) :: \"The {f} is edible\";\n            inedible(f) :: \"The {f} is inedible\";\n            consumed(f) :: \"The {f} is consumed\";\n\n            needs_cooking(f) :: \"The {f} is needs cooking\";\n\n            raw(f) :: \"The {f} is raw\";\n            cooked(f) :: \"The {f} is cooked\";\n            burned(f) :: \"The {f} is burned\";\n            fried(f) :: \"The {f} is fried\";\n            grilled(f) :: \"The {f} is grilled\";\n            roasted(f) :: \"The {f} is roasted\";\n\n            uncut(f) :: \"The {f} is uncut\";\n            sliced(f) :: \"The {f} is sliced\";\n            chopped(f) :: \"The {f} is chopped\";\n            diced(f) :: \"The {f} is diced\";\n        }\n\n        commands {\n            eat :: \"eat {f}\" :: \"eating the {f}\";\n            drink :: \"drink {f}\" :: \"drinking the {f}\";\n            slice :: \"slice {f} with {o}\" :: \"slicing the {f}\";\n            dice  :: \"dice {f} with {o}\"  :: \"dicing the {f}\";\n            chop  :: \"chop {f} with {o}\"  :: \"chopping the {f}\";\n        }\n\n        code :: \"\"\"\n            [Drinking liquid]\n            The block drinking rule is not listed in any rulebook.\n\n            After drinking:\n                Now the noun is consumed;\n                Continue the action.\n\n            Check an actor drinking (this is the can't drink unless drinkable rule):\n                if the noun is not a thing or the noun is not drinkable:\n                    say \"You cannot drink [the noun].\";\n                    rule fails;\n                if the noun is not carried by the player:\n                    say \"You should take [the noun] first.\";\n                    rule fails\n\n            Carry out an actor drinking (this is the drinking rule):\n                remove the noun from play.\n\n            Report an actor drinking (this is the report drinking rule):\n                if the actor is the player:\n                    say \"You drink [the noun]. Not bad.\";\n                otherwise:\n                    say \"[The person asked] just drunk [the noun].\".\n\n            [Eating food]\n            After eating a food (called target):\n                Now the target is consumed;\n                Continue the action.\n\n            Check eating inedible food (called target):\n                if target is needs cooking:\n                    say \"You should cook [the target] first.\";\n                    rule fails.\n\n            [Understanding things by their properties - http://inform7.com/learn/man/WI_17_15.html]\n            Understand the type of cutting property as describing food.\n            Understand the type of cooking property as describing food.\n\n            [Processing food]\n            Understand the commands  \"slice\", \"prune\" as something new.\n            The block cutting rule is not listed in any rulebook.\n            Dicing is an action applying to one carried thing.\n            Slicing is an action applying to one carried thing.\n            Chopping is an action applying to one carried thing.\n\n            Slicing something is a cutting activity.\n            Dicing something is a cutting activity.\n            Chopping something is a cutting activity.\n\n            Check an actor cutting (this is the generic cut is now allowed rule):\n                say \"You need to specify how you want to cut [the noun]. Either slice, dice, or chop it.\";\n                rule fails.\n\n            Before a cutting activity when the noun is not cuttable:\n                say \"Can only cut cuttable food.\";\n                rule fails.\n\n            Before a cutting activity when the noun is cuttable and the noun is not uncut:\n                say \"[The noun] has already been [type of cutting of the noun].\";\n                rule fails.\n\n            Before a cutting activity when the list of sharp things carried by the player is empty:\n                say \"Cutting something requires something sharp like a knife.\";\n                rule fails.\n\n            Before printing the name of a food (called the food item) which is not uncut while looking, examining, listing contents or taking inventory:\n                say \"[type of cutting of food item] \".\n\n\n            [Slicing food]\n            Carry out slicing a carried food (called the food item):\n                Now the food item is sliced;\n                Let sharp object be the entry 1 in the list of sharp things carried by the player;\n                say \"You slice the [food item] using the [sharp object].\".\n\n            Understand \"slice [something]\" as slicing.\n\n            [Dicing food]\n            Carry out dicing a carried food (called the food item):\n                Now the food item is diced;\n                Let sharp object be the entry 1 in the list of sharp things carried by the player;\n                say \"You dice the [food item] using the [sharp object].\";\n\n            Understand \"dice [something]\" as dicing.\n\n            [Chopping food]\n            Carry out chopping a carried food (called the food item):\n                Now the food item is chopped;\n                Let sharp object be the entry 1 in the list of sharp things carried by the player;\n                say \"You chop the [food item] using the [sharp object].\";\n\n            Understand the command \"chop\" as something new. [Remove its association with slicing]\n            Understand \"chop [something]\" as chopping.\n\n            [Cooking food]\n            Cooking is an action applying to one thing.\n\n            Check cooking something not cookable (this is the cook only cookable things rule):\n                say \"[The noun] is not cookable.\" instead.\n\n            Check cooking something cookable when the list of touchable source of heat things is empty (this is the cooking requires a source of heat rule):\n                say \"Cooking requires a source of heat.\" instead.\n\n            Check cooking something cookable not carried by the player (this is the cookable thing location rule):\n                if the noun is not carried by the player and the noun is not on a source of heat thing and the noun is not in a source of heat thing:\n                    say \"[The noun] has to be in your inventory or placed on/in a source of heat.\" instead.\n\n            A rule for reaching inside a source of heat while cooking:\n                allow access.\n\n            After deciding the scope of the player:\n                repeat with source of heat running through the list of source of heat containers:\n                    place the contents of the source of heat in scope.\n\n            Carry out cooking a food (called the food item):\n                Let source of heat be the entry 1 in the list of touchable source of heat things;\n                if the food item is on a source of heat thing (called clocation):\n                    Now the source of heat is the clocation;\n                if the food item is in a source of heat thing (called clocation):\n                    Now the source of heat is the clocation;\n                if the food item is cooked:\n                    Now the food item is burned;\n                    Now the food item is not edible;\n                    say \"You cook the already [type of cooking of food item] [food item] using [the source of heat]. It is burned now!\";\n                    stop;\n                otherwise:\n                    Now the food item is cooked;\n                if the food item is needs cooking:\n                    Now the food item is edible;\n                    Now the food item is not needs cooking;\n                if the source of heat is a stove-like:\n                    Now the food item is fried;\n                    say \"You fry the [food item] using [the source of heat].\";\n                else if the source of heat is a oven-like:\n                    Now the food item is roasted;\n                    say \"You roast the [food item] using [the source of heat].\";\n                else if the source of heat is a bbq-like:\n                    Now the food item is grilled;\n                    say \"You grill the [food item] using [the source of heat].\";\n\n            Understand \"cook [something]\" as cooking.\n\n            Before printing the name of a food (called the food item) while looking, examining, listing contents or taking inventory:\n                if the food item is needs cooking:\n                    say \"raw \";\n                else if the food item is burned:\n                    say \"burned \";\n                else if the food item is not raw:\n                    say \"[type of cooking of food item] \".\n\n        \"\"\";\n    }\n}\n\n# Inventory\ntype I {\n    predicates {\n        in(o, I);\n    }\n\n    rules {\n        take :: $at(P, r) & at(o, r) -> in(o, I);\n        drop :: $at(P, r) & in(o, I) -> at(o, r);\n\n        take/c :: $at(P, r) & $at(c, r) & $open(c) & in(o, c) -> in(o, I);\n        insert :: $at(P, r) & $at(c, r) & $open(c) & in(o, I) -> in(o, c);\n\n        take/s :: $at(P, r) & $at(s, r) & on(o, s) -> in(o, I);\n        put    :: $at(P, r) & $at(s, r) & in(o, I) -> on(o, s);\n\n        examine/I :: at(o, I) -> at(o, I);\n        examine/s :: at(P, r) & $at(s, r) & $on(o, s) -> at(P, r);\n        examine/c :: at(P, r) & $at(c, r) & $open(c) & $in(o, c) -> at(P, r);\n    }\n\n    reverse_rules {\n        take :: drop;\n        take/c :: insert;\n        take/s :: put;\n    }\n\n    inform7 {\n        predicates {\n            in(o, I) :: \"The player carries the {o}\";\n        }\n\n        commands {\n            take :: \"take {o}\" :: \"taking the {o}\";\n            drop :: \"drop {o}\" :: \"dropping the {o}\";\n\n            take/c :: \"take {o} from {c}\" :: \"removing the {o} from the {c}\";\n            insert :: \"insert {o} into {c}\" :: \"inserting the {o} into the {c}\";\n\n            take/s :: \"take {o} from {s}\" :: \"removing the {o} from the {s}\";\n            put :: \"put {o} on {s}\" :: \"putting the {o} on the {s}\";\n\n            inventory :: \"inventory\" :: \"taking inventory\";\n\n            examine/I :: \"examine {o}\" :: \"examining the {o}\";\n            examine/s :: \"examine {o}\" :: \"examining the {o}\";\n            examine/c :: \"examine {o}\" :: \"examining the {o}\";\n        }\n\n        code :: \"\"\"\n            Understand the command \"put\" as something new.\n            Understand \"put [other things] on/onto [something]\" as putting it on.\n\n            Does the player mean putting something on something (called destination):\n                Let L be the list of touchable supporters;\n                if L is not empty and destination is entry 1 of L:\n                    it is very likely;\n                otherwise:\n                    it is very unlikely;\n\n            Does the player mean inserting something into something (called destination):\n                Let L be the list of touchable containers;\n                if L is not empty and destination is entry 1 of L:\n                    it is very likely;\n                otherwise:\n                    it is very unlikely;\n        \"\"\";\n    }\n}\n\n# key\ntype k : o {\n    predicates {\n        match(k, c);\n        match(k, d);\n    }\n\n    constraints {\n        k1 :: match(k, c) & match(k', c) -> fail();\n        k2 :: match(k, c) & match(k, c') -> fail();\n        k3 :: match(k, d) & match(k', d) -> fail();\n        k4 :: match(k, d) & match(k, d') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"key\";\n        }\n\n        predicates {\n            match(k, c) :: \"The matching key of the {c} is the {k}\";\n            match(k, d) :: \"The matching key of the {d} is the {k}\";\n        }\n    }\n}\n\n# object\ntype o : t {\n    constraints {\n        obj1 :: in(o, I) & in(o, c) -> fail();\n        obj2 :: in(o, I) & on(o, s) -> fail();\n        obj3 :: in(o, I) & at(o, r) -> fail();\n        obj4 :: in(o, c) & on(o, s) -> fail();\n        obj5 :: in(o, c) & at(o, r) -> fail();\n        obj6 :: on(o, s) & at(o, r) -> fail();\n        obj7 :: at(o, r) & at(o, r') -> fail();\n        obj8 :: in(o, c) & in(o, c') -> fail();\n        obj9 :: on(o, s) & on(o, s') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"object-like\";\n            definition :: \"object-like is portable.\";\n        }\n\n        predicates {\n            portable(o) :: \"\";\n        }\n\n        code :: \"\"\"\n            Before printing the name of a thing (called the target) while looking, examining or listing contents:\n                say \"[bold type][italic type]\";\n\n            After printing the name of a thing (called the target) while looking, examining or listing contents:\n                say \"[roman type]\";\n        \"\"\";\n    }\n}\n\n# oven\ntype oven : c {\n    rules {\n        cook/oven/raw           :: $at(P, r) & $at(oven, r) & $in(f, I) & raw(f)                         -> roasted(f) & cooked(f);\n        cook/oven/burned        :: $at(P, r) & $at(oven, r) & $in(f, I) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/oven/needs_cooking :: $at(P, r) & $at(oven, r) & $in(f, I) & needs_cooking(f) & inedible(f) -> roasted(f) & edible(f) & cooked(f);\n        cook/inoven/raw           :: $at(P, r) & $at(oven, r) & $in(f, oven) & raw(f)                         -> roasted(f) & cooked(f);\n        cook/inoven/burned        :: $at(P, r) & $at(oven, r) & $in(f, oven) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/inoven/needs_cooking :: $at(P, r) & $at(oven, r) & $in(f, oven) & needs_cooking(f) & inedible(f) -> roasted(f) & edible(f) & cooked(f);\n    }\n\n    inform7 {\n        type {\n            kind :: \"oven-like\";\n            definition :: \"oven-like is a source of heat.\";\n        }\n\n        predicates {\n            heat_source(oven) :: \"\";\n        }\n\n        commands {\n            cook/oven/raw           :: \"cook {f} with {oven}\" :: \"cooking the {f}\";\n            cook/oven/burned        :: \"cook {f} with {oven}\" :: \"cooking the {f}\";\n            cook/oven/needs_cooking :: \"cook {f} with {oven}\" :: \"cooking the {f}\";\n            cook/inoven/raw           :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/inoven/burned        :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/inoven/needs_cooking :: \"cook {f}\" :: \"cooking the {f}\";\n        }\n    }\n}\n\n# text-Like\ntype pr : t {\n    predicates {\n        not_asked(pr);\n        asked(pr);\n    }\n\n    rules {\n        attack/pr   :: $at(P, r) & $at(pr, r) & not_asked(pr) -> asked(pr);\n        ask/pr :: $at(P, r) & $at(pr,r) & $in(f, I) & not_asked(pr) -> asked(pr);\n    }\n    \n    constraints {\n        pr1 :: asked(pr) & not_asked(pr) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"person-like\";\n            definition :: \"person-like can be asked. person-like is fixed in place.\";\n        }\n\n        predicates {\n            asked(pr) :: \"The {pr} is asked\";\n            not_asked(pr) :: \"The {pr} is not asked\";\n        }\n\n        commands {            \n            attack/pr :: \"attack the {pr}\" :: \"_attacking the {pr}\";\n            ask/pr :: \"ask the {pr}\" :: \"_asking the {pr}\";\n        }\n        \n        code :: \"\"\"\n            Understand the command \"ask\" as something new. \n            Understand \"ask [something]\" as _asking. \n            _asking is an action applying to a thing. \n        \n            Carry out _asking: \n                if a person-like (called tx) is not asked: \n                    Say \"The person is being asked about the bank robbery.\";\n                    Now the tx is asked; \n            After _asking: \n                say \"[the noun] has given the information. he said go north.\";\n\n            Understand the command \"attack\" as something new. \n            Understand \"attack [something]\" as _attacking. \n            _attacking is an action applying to a thing. \n        \n            Carry out _attacking the person-like(called tx): \n                Say \"The person is being being attacked.\";\n                Now the tx is asked; \n        \"\"\";\n    }\n}\n\n# Player\ntype P {\n    rules {\n        wait :: at(P, r) -> at(P, r);  # Nothing changes.\n        look :: at(P, r) -> at(P, r);  # Nothing changes.\n\n    }\n\n    inform7 {\n        commands {\n            wait :: \"wait\" :: \"waiting\";\n            look :: \"look\" :: \"looking\";\n        }\n    }\n}\n\ntype rbr : t {\n    predicates {\n        not_stopped(rbr);\n        stopped(rbr);\n    }\n\n    rules {\n        shoot/rbr   :: $at(P, r) & $at(rbr, r) & not_stopped(rbr) -> stopped(rbr);\n        beat/rbr :: $at(P, r) & $at(rbr, r) & not_stopped(rbr) -> stopped(rbr);\n        convince/rbr :: $at(P, r) & $at(rbr, r) & not_stopped(rbr) -> stopped(rbr);\n    }\n    \n    constraints {\n        rbr1 :: stopped(rbr) & not_stopped(rbr) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"robber-like\";\n            definition :: \"robber-like can be open or closed. robber-like are usually open. robber-like is fixed in place.\";\n        }\n\n        predicates {\n            stopped(rbr) :: \"The {rbr} is closed\";\n            not_stopped(rbr) :: \"The {rbr} is open\";\n        }\n\n        commands {            \n            shoot/rbr :: \"shoot the {rbr}\" :: \"_shooting the {rbr}\";\n            beat/rbr :: \"beat the {rbr}\" :: \"_beating the {rbr}\";\n            convince/rbr :: \"convince the {rbr}\" :: \"_convincing the {rbr}\";\n        }\n        \n        code :: \"\"\"\n            Understand the command \"shoot\" as something new. \n            Understand \"shoot [something]\" as _shooting. \n            _shooting is an action applying to a thing. \n        \n            Carry out _shooting the robber-like (called rx): \n                Say \"The [the noun] is being shot. You are successful to stop the robbery.\";\n                Now the rx is closed.\n            After _shooting: \n                say \"You killed [the noun]\";\n\n            Understand the command \"beat\" as something new. \n            Understand \"beat [something]\" as _beating. \n            _beating is an action applying to a thing. \n        \n            Carry out _beating the robber-like (called rx): \n                Say \"The [the noun] is being attacked. You are successful to stop the robbery.\";\n                Now the rx is closed.\n\n            Understand the command \"convince\" as something new. \n            Understand \"convince [something]\" as _convincing. \n            _convincing is an action applying to a thing. \n        \n            Carry out _convincing the robber-like (called rx): \n                Say \"The [the noun] is ready to surrender. You are successful to stop the robbery.\";\n                Now the rx is closed. \n        \"\"\";\n    }\n}\n\n# room\ntype r {\n    predicates {\n        at(P, r);\n        at(t, r);\n\n        north_of(r, r);\n        west_of(r, r);\n\n        north_of/d(r, d, r);\n        west_of/d(r, d, r);\n\n        free(r, r);\n\n        south_of(r, r') = north_of(r', r);\n        east_of(r, r') = west_of(r', r);\n\n        south_of/d(r, d, r') = north_of/d(r', d, r);\n        east_of/d(r, d, r') = west_of/d(r', d, r);\n    }\n\n    rules {\n        go/north :: at(P, r) & $north_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/south :: at(P, r) & $south_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/east  :: at(P, r) & $east_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/west  :: at(P, r) & $west_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n\n    }\n\n    reverse_rules {\n        go/north :: go/south;\n        go/west :: go/east;\n    }\n\n    constraints {\n        r1 :: at(P, r) & at(P, r') -> fail();\n        r2 :: at(s, r) & at(s, r') -> fail();\n        r3 :: at(c, r) & at(c, r') -> fail();\n\n        # An exit direction can only lead to one room.\n        nav_rr1 :: north_of(r, r') & north_of(r'', r') -> fail();\n        nav_rr2 :: south_of(r, r') & south_of(r'', r') -> fail();\n        nav_rr3 :: east_of(r, r') & east_of(r'', r') -> fail();\n        nav_rr4 :: west_of(r, r') & west_of(r'', r') -> fail();\n\n        # Two rooms can only be connected once with each other.\n        nav_rrA :: north_of(r, r') & south_of(r, r') -> fail();\n        nav_rrB :: north_of(r, r') & west_of(r, r') -> fail();\n        nav_rrC :: north_of(r, r') & east_of(r, r') -> fail();\n        nav_rrD :: south_of(r, r') & west_of(r, r') -> fail();\n        nav_rrE :: south_of(r, r') & east_of(r, r') -> fail();\n        nav_rrF :: west_of(r, r')  & east_of(r, r') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"room\";\n        }\n\n        predicates {\n            at(P, r) :: \"The player is in {r}\";\n            at(t, r) :: \"The {t} is in {r}\";\n            #at(c, r) :: \"The {c} is in {r}\";\n            #at(o, r) :: \"The {o} is in {r}\";\n\n            north_of(r, r') :: \"The {r} is mapped north of {r'}\";\n            south_of(r, r') :: \"The {r} is mapped south of {r'}\";\n            east_of(r, r') :: \"The {r} is mapped east of {r'}\";\n            west_of(r, r') :: \"The {r} is mapped west of {r'}\";\n\n            north_of/d(r, d, r') :: \"South of {r} and north of {r'} is a door called {d}\";\n            south_of/d(r, d, r') :: \"North of {r} and south of {r'} is a door called {d}\";\n            east_of/d(r, d, r') :: \"West of {r} and east of {r'} is a door called {d}\";\n            west_of/d(r, d, r') :: \"East of {r} and west of {r'} is a door called {d}\";\n        }\n\n        commands {\n            go/north :: \"go north\" :: \"going north\";\n            go/south :: \"go south\" :: \"going south\";\n            go/east :: \"go east\" :: \"going east\";\n            go/west :: \"go west\" :: \"going west\";\n\n        }\n    }\n}\n\n# stove\ntype stove : s {\n    rules {\n        cook/stove/raw           :: $at(P, r) & $at(stove, r) & $in(f, I) & raw(f)                         -> fried(f) & cooked(f);\n        cook/stove/burned        :: $at(P, r) & $at(stove, r) & $in(f, I) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/stove/needs_cooking :: $at(P, r) & $at(stove, r) & $in(f, I) & needs_cooking(f) & inedible(f) -> fried(f) & edible(f) & cooked(f);\n\n        cook/onstove/raw           :: $at(P, r) & $at(stove, r) & $on(f, stove) & raw(f)                         -> fried(f) & cooked(f);\n        cook/onstove/burned        :: $at(P, r) & $at(stove, r) & $on(f, stove) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/onstove/needs_cooking :: $at(P, r) & $at(stove, r) & $on(f, stove) & needs_cooking(f) & inedible(f) -> fried(f) & edible(f) & cooked(f);\n\n    }\n\n    inform7 {\n        type {\n            kind :: \"stove-like\";\n            definition :: \"stove-like is a source of heat.\";\n        }\n\n        predicates {\n            heat_source(stove) :: \"\";\n        }\n\n        commands {\n            cook/stove/raw           :: \"cook {f} with {stove}\" :: \"cooking the {f}\";\n            cook/stove/burned        :: \"cook {f} with {stove}\" :: \"cooking the {f}\";\n            cook/stove/needs_cooking :: \"cook {f} with {stove}\" :: \"cooking the {f}\";\n            cook/onstove/raw           :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/onstove/burned        :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/onstove/needs_cooking :: \"cook {f}\" :: \"cooking the {f}\";\n        }\n    }\n}\n\n# supporter\ntype s : t {\n    predicates {\n        on(o, s);\n    }\n\n    inform7 {\n        type {\n            kind :: \"supporter\";\n            definition :: \"supporters are fixed in place.\";\n        }\n\n        predicates {\n            on(o, s) :: \"The {o} is on the {s}\";\n            fixed(s) :: \"\";\n            holder(s) :: \"\";\n        }\n\n        code :: \"\"\"\n            After examining a supporter which contains nothing:\n                say \"The [noun] has nothing on it.\".\n        \"\"\";\n    }\n}\n\n# thing\ntype t {\n    predicates {\n        sharp(t);\n        cuttable(t);\n        cookable(t);\n        drinkable(t);\n    }\n\n    rules {\n        examine/t :: at(P, r) & $at(t, r) -> at(P, r);\n    }\n\n    inform7 {\n        type {\n            kind :: \"thing\";\n            definition :: \"a thing can be drinkable. a thing is usually not drinkable. a thing can be cookable. a thing is usually not cookable. a thing can be damaged. a thing is usually not damaged. a thing can be sharp. a thing is usually not sharp. a thing can be cuttable. a thing is usually not cuttable. a thing can be a source of heat. Type of cooking is a kind of value. The type of cooking are raw, grilled, roasted and fried. a thing can be needs cooking. Type of cutting is a kind of value. The type of cutting are uncut, sliced, diced and chopped.\";\n        }\n\n        predicates {\n            sharp(t) :: \"The {t} is sharp\";\n            cookable(t) :: \"The {t} is cookable\";\n            cuttable(t) :: \"The {t} is cuttable\";\n            drinkable(t) :: \"The {t} is drinkable\";\n        }\n\n        commands {\n            examine/t :: \"examine {t}\" :: \"examining the {t}\";\n        }\n    }\n}\n\ntype object {\n    inform7 {\n        type {\n            kind :: \"object\";\n        }\n    }\n}\n\n", "text_grammars_path": "./textworld_data/text_grammars"}, "metadata": {"desc": "Generated with textworld.GameMaker."}, "objective": "", "extras": {}, "main_quest": {"desc": "", "reward": 2, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "asked", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "stopped", "arguments": [{"name": "rbr_0", "type": "rbr"}]}], "postconditions": [{"name": "asked", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "stopped", "arguments": [{"name": "rbr_0", "type": "rbr"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_0", "type": "f"}, {"name": "oven_0", "type": "oven"}, {"name": "r_1", "type": "r"}]}]}}], "fail_events": []}}