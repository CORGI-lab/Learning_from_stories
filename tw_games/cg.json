{"version": 1, "world": [{"name": "aidable", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "aidable", "arguments": [{"name": "pr_1", "type": "pr"}]}, {"name": "aidable", "arguments": [{"name": "pr_2", "type": "pr"}]}, {"name": "askable", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "askable", "arguments": [{"name": "pr_1", "type": "pr"}]}, {"name": "askable", "arguments": [{"name": "pr_2", "type": "pr"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_0", "type": "f"}, {"name": "r_3", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_2", "type": "f"}, {"name": "r_2", "type": "r"}]}, {"name": "at", "arguments": [{"name": "fo_0", "type": "fo"}, {"name": "r_3", "type": "r"}]}, {"name": "at", "arguments": [{"name": "fo_1", "type": "fo"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "fo_2", "type": "fo"}, {"name": "r_2", "type": "r"}]}, {"name": "at", "arguments": [{"name": "pr_0", "type": "pr"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "pr_1", "type": "pr"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "pr_2", "type": "pr"}, {"name": "r_1", "type": "r"}]}, {"name": "east_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "east_of", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "not_aided", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "not_aided", "arguments": [{"name": "pr_1", "type": "pr"}]}, {"name": "not_aided", "arguments": [{"name": "pr_2", "type": "pr"}]}, {"name": "not_stamped", "arguments": [{"name": "fo_0", "type": "fo"}]}, {"name": "not_stamped", "arguments": [{"name": "fo_1", "type": "fo"}]}, {"name": "not_stamped", "arguments": [{"name": "fo_2", "type": "fo"}]}, {"name": "raw", "arguments": [{"name": "f_2", "type": "f"}]}, {"name": "south_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "stampable", "arguments": [{"name": "fo_0", "type": "fo"}]}, {"name": "stampable", "arguments": [{"name": "fo_1", "type": "fo"}]}, {"name": "stampable", "arguments": [{"name": "fo_2", "type": "fo"}]}, {"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}], "grammar": {"theme": "house", "names_to_exclude": [], "include_adj": false, "blend_descriptions": false, "ambiguous_instructions": false, "only_last_action": false, "blend_instructions": false, "allowed_variables_numbering": false, "unique_expansion": false}, "quests": [{"desc": "Who's got a virtual machine and is about to play through an profound round of TextWorld? You do! Here is how to play! First of all, you could, like, lift the blue ticket from the floor of the lobby. Then, stamp the blue ticket. And then, lift the carrot from the floor of the lobby. Once that's all handled, you can stop!", "reward": 1, "commands": ["take blue ticket", "stamp blue ticket", "take carrot"], "win_events": [{"commands": ["take blue ticket", "stamp blue ticket", "take carrot"], "actions": [{"name": "take", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "fo_1", "type": "fo"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "in", "arguments": [{"name": "fo_1", "type": "fo"}, {"name": "I", "type": "I"}]}]}, {"name": "stamp", "preconditions": [{"name": "in", "arguments": [{"name": "fo_1", "type": "fo"}, {"name": "I", "type": "I"}]}, {"name": "not_stamped", "arguments": [{"name": "fo_1", "type": "fo"}]}], "postconditions": [{"name": "stamped", "arguments": [{"name": "fo_1", "type": "fo"}]}]}, {"name": "take", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_1", "type": "f"}, {"name": "I", "type": "I"}]}]}], "condition": {"name": "trigger", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_1", "type": "f"}, {"name": "I", "type": "I"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_1", "type": "f"}, {"name": "I", "type": "I"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}]}}], "fail_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "aided", "arguments": [{"name": "pr_0", "type": "pr"}]}], "postconditions": [{"name": "aided", "arguments": [{"name": "pr_0", "type": "pr"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}]}}]}, {"desc": "Welcome to TextWorld! First stop, attempt to move south. After that, attempt to go west. And then, pick-up the berry from the floor of the office. That's it!", "reward": 1, "commands": ["go south", "go west", "take berry"], "win_events": [{"commands": ["go south", "go west", "take berry"], "actions": [{"name": "go/south", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}]}, {"name": "go/west", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}]}, {"name": "take", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_0", "type": "f"}, {"name": "r_3", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_0", "type": "f"}, {"name": "I", "type": "I"}]}]}], "condition": {"name": "trigger", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_0", "type": "f"}, {"name": "I", "type": "I"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_0", "type": "f"}, {"name": "I", "type": "I"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}]}}], "fail_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "aided", "arguments": [{"name": "pr_1", "type": "pr"}]}], "postconditions": [{"name": "aided", "arguments": [{"name": "pr_1", "type": "pr"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}]}}]}, {"desc": "Welcome to another profound game of TextWorld! First, it would be good if you could take a trip south. And then, venture east. With that over with, retrieve the apple from the floor of the storecloset. And if you do that, you're the winner!", "reward": 1, "commands": ["go south", "go east", "take apple"], "win_events": [{"commands": ["go south", "go east", "take apple"], "actions": [{"name": "go/south", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}]}, {"name": "go/east", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}]}, {"name": "take", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_2", "type": "f"}, {"name": "r_2", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_2", "type": "f"}, {"name": "I", "type": "I"}]}]}], "condition": {"name": "trigger", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_2", "type": "f"}, {"name": "I", "type": "I"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_2", "type": "f"}, {"name": "I", "type": "I"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}]}}], "fail_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "aided", "arguments": [{"name": "pr_2", "type": "pr"}]}], "postconditions": [{"name": "aided", "arguments": [{"name": "pr_2", "type": "pr"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}]}}]}], "infos": [["P", {"id": "P", "type": "P", "name": null, "noun": null, "adj": null, "desc": null, "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["I", {"id": "I", "type": "I", "name": null, "noun": null, "adj": null, "desc": null, "room_type": null, "definite": null, "indefinite": null, "synonyms": null}], ["r_0", {"id": "r_0", "type": "r", "name": "counter", "noun": null, "adj": null, "desc": "You are now behind your counter.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["r_3", {"id": "r_3", "type": "r", "name": "office", "noun": null, "adj": null, "desc": "This is your office. There's not much here aside from a desk with your work on it.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["r_2", {"id": "r_2", "type": "r", "name": "storecloset", "noun": null, "adj": null, "desc": "This is the storage room where you keep the doodads. There is one last doodad.", "room_type": "storage", "definite": null, "indefinite": null, "synonyms": null}], ["r_1", {"id": "r_1", "type": "r", "name": "lobby", "noun": null, "adj": null, "desc": "This is the clerk office lobby.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["pr_0", {"id": "pr_0", "type": "pr", "name": "coworker", "noun": null, "adj": null, "desc": "This person is your coworker. They look stressed.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["pr_1", {"id": "pr_1", "type": "pr", "name": "customer", "noun": null, "adj": null, "desc": "This is a customer waiting at the wrong window.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["pr_2", {"id": "pr_2", "type": "pr", "name": "shopper", "noun": null, "adj": null, "desc": "This is a potential customer confused at a shelf.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["f_0", {"id": "f_0", "type": "f", "name": "berry", "noun": null, "adj": null, "desc": "That's a [noun]!", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["f_1", {"id": "f_1", "type": "f", "name": "carrot", "noun": null, "adj": null, "desc": "That's a [noun]!", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["f_2", {"id": "f_2", "type": "f", "name": "apple", "noun": null, "adj": null, "desc": "You couldn't pay me to eat that [noun].", "room_type": "storage", "definite": null, "indefinite": null, "synonyms": null}], ["fo_0", {"id": "fo_0", "type": "fo", "name": "red receipt", "noun": null, "adj": null, "desc": "It's a waybill.", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["fo_1", {"id": "fo_1", "type": "fo", "name": "blue ticket", "noun": null, "adj": null, "desc": "It's a form.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["fo_2", {"id": "fo_2", "type": "fo", "name": "green formbill", "noun": null, "adj": null, "desc": "It's a form.", "room_type": "storage", "definite": null, "indefinite": null, "synonyms": null}]], "KB": {"logic": "type bbq : t {\n    rules {\n        cook/bbq/raw           :: $at(P, r) & $at(bbq, r) & $in(f, I) & raw(f)                         -> grilled(f) & cooked(f);\n        cook/bbq/burned        :: $at(P, r) & $at(bbq, r) & $in(f, I) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/bbq/needs_cooking :: $at(P, r) & $at(bbq, r) & $in(f, I) & needs_cooking(f) & inedible(f) -> grilled(f) & edible(f) & cooked(f);\n    }\n\n    inform7 {\n        type {\n            kind :: \"bbq-like\";\n            definition :: \"bbq-like is a source of heat. bbq-like are fixed in place.\";\n        }\n\n        predicates {\n            heat_source(bbq) :: \"\";\n            fixed(bbq) :: \"\";\n        }\n\n        commands {\n            cook/bbq/raw           :: \"cook {f} with {bbq}\" :: \"cooking the {f}\";\n            cook/bbq/burned        :: \"cook {f} with {bbq}\" :: \"cooking the {f}\";\n            cook/bbq/needs_cooking :: \"cook {f} with {bbq}\" :: \"cooking the {f}\";\n        }\n    }\n}\n\n# container\ntype c : t {\n    predicates {\n        open(c);\n        closed(c);\n        locked(c);\n\n        in(o, c);\n    }\n\n    rules {\n        lock/c   :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & closed(c) -> locked(c);\n        unlock/c :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & locked(c) -> closed(c);\n\n        open/c  :: $at(P, r) & $at(c, r) & closed(c) -> open(c);\n        close/c :: $at(P, r) & $at(c, r) & open(c) -> closed(c);\n    }\n\n    reverse_rules {\n        lock/c :: unlock/c;\n        open/c :: close/c;\n    }\n\n    constraints {\n        c1 :: open(c)   & closed(c) -> fail();\n        c2 :: open(c)   & locked(c) -> fail();\n        c3 :: closed(c) & locked(c) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"container\";\n            definition :: \"containers are openable, lockable and fixed in place. containers are usually closed.\";\n        }\n\n        predicates {\n            open(c) :: \"The {c} is open\";\n            closed(c) :: \"The {c} is closed\";\n            locked(c) :: \"The {c} is locked\";\n\n            in(o, c) :: \"The {o} is in the {c}\";\n            holder(c) :: \"\";\n            openable(c) :: \"\";\n            closeable(c) :: \"\";\n            lockable(c) :: \"\";\n            unlockable(c) :: \"\";\n            fixed(c) :: \"\";\n        }\n\n        commands {\n            open/c :: \"open {c}\" :: \"opening the {c}\";\n            close/c :: \"close {c}\" :: \"closing the {c}\";\n\n            lock/c :: \"lock {c} with {k}\" :: \"locking the {c} with the {k}\";\n            unlock/c :: \"unlock {c} with {k}\" :: \"unlocking the {c} with the {k}\";\n        }\n\n        code :: \"\"\"\n            After examining an open container which contains nothing:\n                say \"It's empty.\".\n        \"\"\";\n    }\n}\n\n# door\ntype d : t {\n    predicates {\n        open(d);\n        closed(d);\n        locked(d);\n\n        link(r, d, r);\n    }\n\n    rules {\n        lock/d   :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & closed(d) -> locked(d);\n        unlock/d :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & locked(d) -> closed(d);\n\n        open/d   :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & closed(d) -> open(d) & free(r, r') & free(r', r);\n        close/d  :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & open(d) & free(r, r') & free(r', r) -> closed(d);\n\n        enter/d :: at(P, r) & $link(r, d, r') -> at(P, r');\n    }\n\n    reverse_rules {\n        lock/d :: unlock/d;\n        open/d :: close/d;\n    }\n\n    constraints {\n        d1 :: open(d)   & closed(d) -> fail();\n        d2 :: open(d)   & locked(d) -> fail();\n        d3 :: closed(d) & locked(d) -> fail();\n\n        # A door can't be used to link more than two rooms.\n        link1 :: link(r, d, r') & link(r, d, r'') -> fail();\n        link2 :: link(r, d, r') & link(r'', d, r''') -> fail();\n\n        # There's already a door linking two rooms.\n        link3 :: link(r, d, r') & link(r, d', r') -> fail();\n\n        # There cannot be more than four doors in a room.\n        dr2 :: link(r, d1: d, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n\n        free1 :: link(r, d, r') & free(r, r') & closed(d) -> fail();\n        free2 :: link(r, d, r') & free(r, r') & locked(d) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"door\";\n            definition :: \"door is openable and lockable.\";\n        }\n\n        predicates {\n            open(d) :: \"The {d} is open\";\n            closed(d) :: \"The {d} is closed\";\n            locked(d) :: \"The {d} is locked\";\n            link(r, d, r') :: \"\";  # No equivalent in Inform7.\n            openable(d) :: \"\";\n            closeable(d) :: \"\";\n            lockable(d) :: \"\";\n            unlockable(d) :: \"\";\n            fixed(d) :: \"\";\n        }\n\n        commands {\n            open/d :: \"open {d}\" :: \"opening {d}\";\n            close/d :: \"close {d}\" :: \"closing {d}\";\n\n            unlock/d :: \"unlock {d} with {k}\" :: \"unlocking {d} with the {k}\";\n            lock/d :: \"lock {d} with {k}\" :: \"locking {d} with the {k}\";\n\n            enter/d :: \"enter {d}\" :: \"entering {d}\";\n        }\n    }\n}\n\n# food\ntype f : o {\n    predicates {\n        consumed(f);\n        edible(f);\n        inedible(f);\n\n        needs_cooking(f);\n        raw(f);\n        cooked(f);\n        burned(f);\n\n        roasted(f);\n        fried(f);\n        grilled(f);\n        # boiled(f);\n        # steamed(f);\n\n        uncut(f);\n        chopped(f);\n        sliced(f);\n        diced(f);\n    }\n\n    rules {\n        eat :: in(f, I) & edible(f) -> consumed(f);\n        drink :: in(f, I) & drinkable(f) -> consumed(f);\n        slice :: $in(f, I) & $in(o, I) & $sharp(o) & uncut(f) -> sliced(f);\n        dice :: $in(f, I) & $in(o, I) & $sharp(o) & uncut(f) -> diced(f);\n        chop :: $in(f, I) & $in(o, I) & $sharp(o) & uncut(f) -> chopped(f);\n    }\n\n    constraints {\n        consumed1 :: consumed(f) & in(f, I) -> fail();\n        consumed2 :: consumed(f) & in(f, c) -> fail();\n        consumed3 :: consumed(f) & on(f, s) -> fail();\n        consumed4 :: consumed(f) & at(f, r) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"food\";\n            definition :: \"food is usually edible. food is cookable. food has a type of cooking. food has a type of cutting. food can be cooked. food can be burned. food can be consumed. food is usually not consumed. food is usually cuttable.\";\n        }\n\n        predicates {\n            edible(f) :: \"The {f} is edible\";\n            inedible(f) :: \"The {f} is inedible\";\n            consumed(f) :: \"The {f} is consumed\";\n\n            needs_cooking(f) :: \"The {f} is needs cooking\";\n\n            raw(f) :: \"The {f} is raw\";\n            cooked(f) :: \"The {f} is cooked\";\n            burned(f) :: \"The {f} is burned\";\n            fried(f) :: \"The {f} is fried\";\n            grilled(f) :: \"The {f} is grilled\";\n            roasted(f) :: \"The {f} is roasted\";\n\n            uncut(f) :: \"The {f} is uncut\";\n            sliced(f) :: \"The {f} is sliced\";\n            chopped(f) :: \"The {f} is chopped\";\n            diced(f) :: \"The {f} is diced\";\n        }\n\n        commands {\n            eat :: \"eat {f}\" :: \"eating the {f}\";\n            drink :: \"drink {f}\" :: \"drinking the {f}\";\n            slice :: \"slice {f} with {o}\" :: \"slicing the {f}\";\n            dice  :: \"dice {f} with {o}\"  :: \"dicing the {f}\";\n            chop  :: \"chop {f} with {o}\"  :: \"chopping the {f}\";\n        }\n\n        code :: \"\"\"\n            [Drinking liquid]\n            The block drinking rule is not listed in any rulebook.\n\n            After drinking:\n                Now the noun is consumed;\n                Continue the action.\n\n            Check an actor drinking (this is the can't drink unless drinkable rule):\n                if the noun is not a thing or the noun is not drinkable:\n                    say \"You cannot drink [the noun].\";\n                    rule fails;\n                if the noun is not carried by the player:\n                    say \"You should take [the noun] first.\";\n                    rule fails\n\n            Carry out an actor drinking (this is the drinking rule):\n                remove the noun from play.\n\n            Report an actor drinking (this is the report drinking rule):\n                if the actor is the player:\n                    say \"You drink [the noun]. Not bad.\";\n                otherwise:\n                    say \"[The person asked] just drunk [the noun].\".\n\n            [Eating food]\n            After eating a food (called target):\n                Now the target is consumed;\n                Continue the action.\n\n            Check eating inedible food (called target):\n                if target is needs cooking:\n                    say \"You should cook [the target] first.\";\n                    rule fails.\n\n            [Understanding things by their properties - http://inform7.com/learn/man/WI_17_15.html]\n            Understand the type of cutting property as describing food.\n            Understand the type of cooking property as describing food.\n\n            [Processing food]\n            Understand the commands  \"slice\", \"prune\" as something new.\n            The block cutting rule is not listed in any rulebook.\n            Dicing is an action applying to one carried thing.\n            Slicing is an action applying to one carried thing.\n            Chopping is an action applying to one carried thing.\n\n            Slicing something is a cutting activity.\n            Dicing something is a cutting activity.\n            Chopping something is a cutting activity.\n\n            Check an actor cutting (this is the generic cut is now allowed rule):\n                say \"You need to specify how you want to cut [the noun]. Either slice, dice, or chop it.\";\n                rule fails.\n\n            Before a cutting activity when the noun is not cuttable:\n                say \"Can only cut cuttable food.\";\n                rule fails.\n\n            Before a cutting activity when the noun is cuttable and the noun is not uncut:\n                say \"[The noun] has already been [type of cutting of the noun].\";\n                rule fails.\n\n            Before a cutting activity when the list of sharp things carried by the player is empty:\n                say \"Cutting something requires something sharp like a knife.\";\n                rule fails.\n\n            Before printing the name of a food (called the food item) which is not uncut while looking, examining, listing contents or taking inventory:\n                say \"[type of cutting of food item] \".\n\n\n            [Slicing food]\n            Carry out slicing a carried food (called the food item):\n                Now the food item is sliced;\n                Let sharp object be the entry 1 in the list of sharp things carried by the player;\n                say \"You slice the [food item] using the [sharp object].\".\n\n            Understand \"slice [something]\" as slicing.\n\n            [Dicing food]\n            Carry out dicing a carried food (called the food item):\n                Now the food item is diced;\n                Let sharp object be the entry 1 in the list of sharp things carried by the player;\n                say \"You dice the [food item] using the [sharp object].\";\n\n            Understand \"dice [something]\" as dicing.\n\n            [Chopping food]\n            Carry out chopping a carried food (called the food item):\n                Now the food item is chopped;\n                Let sharp object be the entry 1 in the list of sharp things carried by the player;\n                say \"You chop the [food item] using the [sharp object].\";\n\n            Understand the command \"chop\" as something new. [Remove its association with slicing]\n            Understand \"chop [something]\" as chopping.\n\n            [Cooking food]\n            Cooking is an action applying to one thing.\n\n            Check cooking something not cookable (this is the cook only cookable things rule):\n                say \"[The noun] is not cookable.\" instead.\n\n            Check cooking something cookable when the list of touchable source of heat things is empty (this is the cooking requires a source of heat rule):\n                say \"Cooking requires a source of heat.\" instead.\n\n            Check cooking something cookable not carried by the player (this is the cookable thing location rule):\n                if the noun is not carried by the player and the noun is not on a source of heat thing and the noun is not in a source of heat thing:\n                    say \"[The noun] has to be in your inventory or placed on/in a source of heat.\" instead.\n\n            A rule for reaching inside a source of heat while cooking:\n                allow access.\n\n            After deciding the scope of the player:\n                repeat with source of heat running through the list of source of heat containers:\n                    place the contents of the source of heat in scope.\n\n            Carry out cooking a food (called the food item):\n                Let source of heat be the entry 1 in the list of touchable source of heat things;\n                if the food item is on a source of heat thing (called clocation):\n                    Now the source of heat is the clocation;\n                if the food item is in a source of heat thing (called clocation):\n                    Now the source of heat is the clocation;\n                if the food item is cooked:\n                    Now the food item is burned;\n                    Now the food item is not edible;\n                    say \"You cook the already [type of cooking of food item] [food item] using [the source of heat]. It is burned now!\";\n                    stop;\n                otherwise:\n                    Now the food item is cooked;\n                if the food item is needs cooking:\n                    Now the food item is edible;\n                    Now the food item is not needs cooking;\n                if the source of heat is a stove-like:\n                    Now the food item is fried;\n                    say \"You fry the [food item] using [the source of heat].\";\n                else if the source of heat is a oven-like:\n                    Now the food item is roasted;\n                    say \"You roast the [food item] using [the source of heat].\";\n                else if the source of heat is a bbq-like:\n                    Now the food item is grilled;\n                    say \"You grill the [food item] using [the source of heat].\";\n\n            Understand \"cook [something]\" as cooking.\n\n            Before printing the name of a food (called the food item) while looking, examining, listing contents or taking inventory:\n                if the food item is needs cooking:\n                    say \"raw \";\n                else if the food item is burned:\n                    say \"burned \";\n                else if the food item is not raw:\n                    say \"[type of cooking of food item] \".\n\n        \"\"\";\n    }\n}\n\n# Inventory\ntype I {\n    predicates {\n        in(o, I);\n    }\n\n    rules {\n        take :: $at(P, r) & at(o, r) -> in(o, I);\n        drop :: $at(P, r) & in(o, I) -> at(o, r);\n\n        take/c :: $at(P, r) & $at(c, r) & $open(c) & in(o, c) -> in(o, I);\n        insert :: $at(P, r) & $at(c, r) & $open(c) & in(o, I) -> in(o, c);\n\n        take/s :: $at(P, r) & $at(s, r) & on(o, s) -> in(o, I);\n        put    :: $at(P, r) & $at(s, r) & in(o, I) -> on(o, s);\n\n        examine/I :: at(o, I) -> at(o, I);\n        examine/s :: at(P, r) & $at(s, r) & $on(o, s) -> at(P, r);\n        examine/c :: at(P, r) & $at(c, r) & $open(c) & $in(o, c) -> at(P, r);\n    }\n\n    reverse_rules {\n        take :: drop;\n        take/c :: insert;\n        take/s :: put;\n    }\n\n    inform7 {\n        predicates {\n            in(o, I) :: \"The player carries the {o}\";\n        }\n\n        commands {\n            take :: \"take {o}\" :: \"taking the {o}\";\n            drop :: \"drop {o}\" :: \"dropping the {o}\";\n\n            take/c :: \"take {o} from {c}\" :: \"removing the {o} from the {c}\";\n            insert :: \"insert {o} into {c}\" :: \"inserting the {o} into the {c}\";\n\n            take/s :: \"take {o} from {s}\" :: \"removing the {o} from the {s}\";\n            put :: \"put {o} on {s}\" :: \"putting the {o} on the {s}\";\n\n            inventory :: \"inventory\" :: \"taking inventory\";\n\n            examine/I :: \"examine {o}\" :: \"examining the {o}\";\n            examine/s :: \"examine {o}\" :: \"examining the {o}\";\n            examine/c :: \"examine {o}\" :: \"examining the {o}\";\n        }\n\n        code :: \"\"\"\n            Understand the command \"put\" as something new.\n            Understand \"put [other things] on/onto [something]\" as putting it on.\n\n            Does the player mean putting something on something (called destination):\n                Let L be the list of touchable supporters;\n                if L is not empty and destination is entry 1 of L:\n                    it is very likely;\n                otherwise:\n                    it is very unlikely;\n\n            Does the player mean inserting something into something (called destination):\n                Let L be the list of touchable containers;\n                if L is not empty and destination is entry 1 of L:\n                    it is very likely;\n                otherwise:\n                    it is very unlikely;\n        \"\"\";\n    }\n}\n\n# key\ntype k : o {\n    predicates {\n        match(k, c);\n        match(k, d);\n    }\n\n    constraints {\n        k1 :: match(k, c) & match(k', c) -> fail();\n        k2 :: match(k, c) & match(k, c') -> fail();\n        k3 :: match(k, d) & match(k', d) -> fail();\n        k4 :: match(k, d) & match(k, d') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"key\";\n        }\n\n        predicates {\n            match(k, c) :: \"The matching key of the {c} is the {k}\";\n            match(k, d) :: \"The matching key of the {d} is the {k}\";\n        }\n    }\n}\n\n# object\ntype o : t {\n    constraints {\n        obj1 :: in(o, I) & in(o, c) -> fail();\n        obj2 :: in(o, I) & on(o, s) -> fail();\n        obj3 :: in(o, I) & at(o, r) -> fail();\n        obj4 :: in(o, c) & on(o, s) -> fail();\n        obj5 :: in(o, c) & at(o, r) -> fail();\n        obj6 :: on(o, s) & at(o, r) -> fail();\n        obj7 :: at(o, r) & at(o, r') -> fail();\n        obj8 :: in(o, c) & in(o, c') -> fail();\n        obj9 :: on(o, s) & on(o, s') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"object-like\";\n            definition :: \"object-like is portable.\";\n        }\n\n        predicates {\n            portable(o) :: \"\";\n        }\n\n        code :: \"\"\"\n            Before printing the name of a thing (called the target) while looking, examining or listing contents:\n                say \"[bold type][italic type]\";\n\n            After printing the name of a thing (called the target) while looking, examining or listing contents:\n                say \"[roman type]\";\n        \"\"\";\n    }\n}\n\n# oven\ntype oven : c {\n    rules {\n        cook/oven/raw           :: $at(P, r) & $at(oven, r) & $in(f, I) & raw(f)                         -> roasted(f) & cooked(f);\n        cook/oven/burned        :: $at(P, r) & $at(oven, r) & $in(f, I) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/oven/needs_cooking :: $at(P, r) & $at(oven, r) & $in(f, I) & needs_cooking(f) & inedible(f) -> roasted(f) & edible(f) & cooked(f);\n        cook/inoven/raw           :: $at(P, r) & $at(oven, r) & $in(f, oven) & raw(f)                         -> roasted(f) & cooked(f);\n        cook/inoven/burned        :: $at(P, r) & $at(oven, r) & $in(f, oven) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/inoven/needs_cooking :: $at(P, r) & $at(oven, r) & $in(f, oven) & needs_cooking(f) & inedible(f) -> roasted(f) & edible(f) & cooked(f);\n    }\n\n    inform7 {\n        type {\n            kind :: \"oven-like\";\n            definition :: \"oven-like is a source of heat.\";\n        }\n\n        predicates {\n            heat_source(oven) :: \"\";\n        }\n\n        commands {\n            cook/oven/raw           :: \"cook {f} with {oven}\" :: \"cooking the {f}\";\n            cook/oven/burned        :: \"cook {f} with {oven}\" :: \"cooking the {f}\";\n            cook/oven/needs_cooking :: \"cook {f} with {oven}\" :: \"cooking the {f}\";\n            cook/inoven/raw           :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/inoven/burned        :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/inoven/needs_cooking :: \"cook {f}\" :: \"cooking the {f}\";\n        }\n    }\n}\n\n# person\ntype pr : o {\n    predicates {\n        not_asked(pr);\n        askable(pr);\n        asked(pr);\n        attacked(pr);\n        stressed(pr);\n        not_aided(pr);\n        not_stressed(pr);\n        aided(pr);\n    }\n\n    rules {\n        ask :: $at(P, r) & $at(pr,r) & askable(pr) -> asked(pr);\n        aid :: $at(P, r) & $at(pr,r) & aidable(pr) -> aided(pr);\n    }\n\n    constraints {\n        pr1 :: asked(pr) & not_asked(pr) -> fail();\n        pr2 :: aided(pr) & not_aided(pr) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"person-like\";\n            definition ::  \"person-like can be asked. person-like can be askable. person-like can be aidable. person-like can be seen. person-like can be examined. person-like can be stressed. person-like can be aided. person-like are usually not aided. person-like is fixed in place.\";\n        }\n\n        predicates {\n            attacked(pr)  :: \"The {pr} is attacked\";\n            aided(pr) :: \"The {pr} is aided\";\n            asked(pr) :: \"The {pr} is asked\";\n            not_asked(pr) :: \"The {pr} is not asked\";\n            askable(pr) :: \"The {pr} can be asked\";\n            aidable(pr) :: \"The {pr} can be aided\";\n            stressed(pr) :: \"The {pr} is stressed\";\n            not_stressed(pr) :: \"The {pr} is not stressed\";\n            not_aided(pr) :: \"The {pr} is not aided\";\n        }\n\n        commands {\n            ask :: \"ask the {pr}\" :: \"asking the {pr}\";\n            aid :: \"aid the {pr}\" :: \"aiding the {pr}\";\n        }\n\n        code :: \"\"\"\n            [Asking]\n            Understand the command \"ask\" as something new. \n            Understand \"ask [something]\" as asking. \n            asking is an action applying to a thing. \n\n            Carry out asking: \n                if a person-like (called tx) is askable: \n                    say \"The person is trying to get something done but is having a hard time...\";\n                    Now the tx is asked;\n            After asking: \n                Say \"[the noun] they could use your aid.\";\n\n            [Aiding]\n            Understand the command \"aid\" as something new. \n            Understand \"aid [something]\" as aiding. \n            aiding is an action applying to a thing. \n\n            Carry out aiding: \n                if a person-like (called px) is aidable: \n                    say \"You aid the person with their problem.\";\n                    Now the px is aided; \n            After aiding: \n                Say \"They appreciate your aid.\";\n        \"\"\";\n    }\n}\n\n# Player\ntype P {\n    rules {\n        wait :: at(P, r) -> at(P, r);  # Nothing changes.\n        look :: at(P, r) -> at(P, r);  # Nothing changes.\n\n    }\n\n    inform7 {\n        commands {\n            wait :: \"wait\" :: \"waiting\";\n            look :: \"look\" :: \"looking\";\n        }\n    }\n}\n\n# room\ntype r {\n    predicates {\n        at(P, r);\n        at(t, r);\n\n        north_of(r, r);\n        west_of(r, r);\n\n        north_of/d(r, d, r);\n        west_of/d(r, d, r);\n\n        free(r, r);\n\n        south_of(r, r') = north_of(r', r);\n        east_of(r, r') = west_of(r', r);\n\n        south_of/d(r, d, r') = north_of/d(r', d, r);\n        east_of/d(r, d, r') = west_of/d(r', d, r);\n    }\n\n    rules {\n        go/north :: at(P, r) & $north_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/south :: at(P, r) & $south_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/east  :: at(P, r) & $east_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/west  :: at(P, r) & $west_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n\n    }\n\n    reverse_rules {\n        go/north :: go/south;\n        go/west :: go/east;\n    }\n\n    constraints {\n        r1 :: at(P, r) & at(P, r') -> fail();\n        r2 :: at(s, r) & at(s, r') -> fail();\n        r3 :: at(c, r) & at(c, r') -> fail();\n\n        # An exit direction can only lead to one room.\n        nav_rr1 :: north_of(r, r') & north_of(r'', r') -> fail();\n        nav_rr2 :: south_of(r, r') & south_of(r'', r') -> fail();\n        nav_rr3 :: east_of(r, r') & east_of(r'', r') -> fail();\n        nav_rr4 :: west_of(r, r') & west_of(r'', r') -> fail();\n\n        # Two rooms can only be connected once with each other.\n        nav_rrA :: north_of(r, r') & south_of(r, r') -> fail();\n        nav_rrB :: north_of(r, r') & west_of(r, r') -> fail();\n        nav_rrC :: north_of(r, r') & east_of(r, r') -> fail();\n        nav_rrD :: south_of(r, r') & west_of(r, r') -> fail();\n        nav_rrE :: south_of(r, r') & east_of(r, r') -> fail();\n        nav_rrF :: west_of(r, r')  & east_of(r, r') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"room\";\n        }\n\n        predicates {\n            at(P, r) :: \"The player is in {r}\";\n            at(t, r) :: \"The {t} is in {r}\";\n            #at(c, r) :: \"The {c} is in {r}\";\n            #at(o, r) :: \"The {o} is in {r}\";\n\n            north_of(r, r') :: \"The {r} is mapped north of {r'}\";\n            south_of(r, r') :: \"The {r} is mapped south of {r'}\";\n            east_of(r, r') :: \"The {r} is mapped east of {r'}\";\n            west_of(r, r') :: \"The {r} is mapped west of {r'}\";\n\n            north_of/d(r, d, r') :: \"South of {r} and north of {r'} is a door called {d}\";\n            south_of/d(r, d, r') :: \"North of {r} and south of {r'} is a door called {d}\";\n            east_of/d(r, d, r') :: \"West of {r} and east of {r'} is a door called {d}\";\n            west_of/d(r, d, r') :: \"East of {r} and west of {r'} is a door called {d}\";\n        }\n\n        commands {\n            go/north :: \"go north\" :: \"going north\";\n            go/south :: \"go south\" :: \"going south\";\n            go/east :: \"go east\" :: \"going east\";\n            go/west :: \"go west\" :: \"going west\";\n\n        }\n    }\n}\n\n# stove\ntype stove : s {\n    rules {\n        cook/stove/raw           :: $at(P, r) & $at(stove, r) & $in(f, I) & raw(f)                         -> fried(f) & cooked(f);\n        cook/stove/burned        :: $at(P, r) & $at(stove, r) & $in(f, I) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/stove/needs_cooking :: $at(P, r) & $at(stove, r) & $in(f, I) & needs_cooking(f) & inedible(f) -> fried(f) & edible(f) & cooked(f);\n\n        cook/onstove/raw           :: $at(P, r) & $at(stove, r) & $on(f, stove) & raw(f)                         -> fried(f) & cooked(f);\n        cook/onstove/burned        :: $at(P, r) & $at(stove, r) & $on(f, stove) & cooked(f) & edible(f)          -> burned(f) & inedible(f);\n        cook/onstove/needs_cooking :: $at(P, r) & $at(stove, r) & $on(f, stove) & needs_cooking(f) & inedible(f) -> fried(f) & edible(f) & cooked(f);\n\n    }\n\n    inform7 {\n        type {\n            kind :: \"stove-like\";\n            definition :: \"stove-like is a source of heat.\";\n        }\n\n        predicates {\n            heat_source(stove) :: \"\";\n        }\n\n        commands {\n            cook/stove/raw           :: \"cook {f} with {stove}\" :: \"cooking the {f}\";\n            cook/stove/burned        :: \"cook {f} with {stove}\" :: \"cooking the {f}\";\n            cook/stove/needs_cooking :: \"cook {f} with {stove}\" :: \"cooking the {f}\";\n            cook/onstove/raw           :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/onstove/burned        :: \"cook {f}\" :: \"cooking the {f}\";\n            cook/onstove/needs_cooking :: \"cook {f}\" :: \"cooking the {f}\";\n        }\n    }\n}\n\n# supporter\ntype s : t {\n    predicates {\n        on(o, s);\n    }\n\n    inform7 {\n        type {\n            kind :: \"supporter\";\n            definition :: \"supporters are fixed in place.\";\n        }\n\n        predicates {\n            on(o, s) :: \"The {o} is on the {s}\";\n            fixed(s) :: \"\";\n            holder(s) :: \"\";\n        }\n\n        code :: \"\"\"\n            After examining a supporter which contains nothing:\n                say \"The [noun] has nothing on it.\".\n        \"\"\";\n    }\n}\n\n# thing\ntype t {\n    predicates {\n        sharp(t);\n        cuttable(t);\n        cookable(t);\n        drinkable(t);\n    }\n\n    inform7 {\n\n        type {\n            kind :: \"thing\";\n            definition :: \"thing can be something. thing can be drinkable. thing is usually not drinkable. thing can be cookable. thing is usually not cookable. a thing can be damaged. a thing is usually not damaged. a thing can be sharp. a thing is usually not sharp. a thing can be cuttable. a thing is usually not cuttable. a thing can be a source of heat. Type of cooking is a kind of value. The type of cooking are raw, grilled, roasted and fried. a thing can be needs cooking. Type of cutting is a kind of value. The type of cutting are uncut, sliced, diced and chopped.\";\n        }\n\n        predicates {\n            sharp(t) :: \"The {t} is sharp\";\n            cookable(t) :: \"The {t} is cookable\";\n            cuttable(t) :: \"The {t} is cuttable\";\n            drinkable(t) :: \"The {t} is drinkable\";\n        }\n\n        commands {\n            examine/t :: \"examine {t}\" :: \"examining the {t}\";\n        }\n\n    }\n}\n\n\ntype object {\n    inform7 {\n        type {\n            kind :: \"object\";\n        }\n    }\n}\n#waybill\ntype fo : o {\n    predicates {\n        stampable(fo);\n        stamped(fo);\n        stampless(fo);\n        not_stamped(fo);\n    }\n\n    rules {\n        stamp :: in(fo, I) & not_stamped(fo) -> stamped(fo);\n    }\n\n    constraints {\n        fo1 :: stamped(fo) & not_stamped(fo) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"waybill\";\n            definition :: \"waybills can be stamped. waybills can be stampable. waybills are portable. waybills can be seen. waybills can be examined. waybills can be on something. waybills are usually not stamped. waybills can be stampless.\";\n        }\n\n        predicates {\n            stampable(fo) :: \"The {fo} is stampable\";\n            stamped(fo) :: \"The {fo} is stamped\";\n            stampless(fo) :: \"The {fo} is stampless\";\n            not_stamped(fo) :: \"The {fo} is not stamped\";\n        }\n\n        commands {\n            stamp :: \"stamp {fo}\" :: \"stamping the {fo}\";\n        }\n\n        code :: \"\"\"\n            Understand the command \"stamp\" as something new. \n            Understand \"stamp [something]\" as stamping. \n            stamping is an action applying to a thing. \n\n            Carry out stamping: \n                if a waybill (called tx) is not stamped: \n                    say \"You stamp it.\";\n                    Now the tx is stamped; \n            After stamping: \n                Say \"It is now stamped.\";\n        \"\"\";\n    }\n}\n\n", "text_grammars_path": "./textworld_data/text_grammars"}, "metadata": {"desc": "Generated with textworld.GameMaker."}, "objective": "Welcome to TextWorld! First off, if it's not too much trouble, I need you to pick-up the carrot from the floor of the lobby. And then, attempt to head south. After that, make an effort to head west. Following that, lift the berry from the floor of the office. If you can get your hands on the berry, make an effort to move east. Then, attempt to go east. After that, pick-up the apple from the floor of the storecloset. That's it!", "extras": {}, "main_quest": {"desc": "Welcome to TextWorld! First off, if it's not too much trouble, I need you to pick-up the carrot from the floor of the lobby. And then, attempt to head south. After that, make an effort to head west. Following that, lift the berry from the floor of the office. If you can get your hands on the berry, make an effort to move east. Then, attempt to go east. After that, pick-up the apple from the floor of the storecloset. That's it!", "reward": 1, "commands": ["take carrot", "go south", "go west", "take berry", "go east", "go east", "take apple"], "win_events": [{"commands": [], "actions": [{"name": "take", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_1", "type": "f"}, {"name": "I", "type": "I"}]}]}, {"name": "go/south", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}], "postconditions": [{"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}]}, {"name": "go/west", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}]}, {"name": "take", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_0", "type": "f"}, {"name": "r_3", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_0", "type": "f"}, {"name": "I", "type": "I"}]}]}, {"name": "go/east", "preconditions": [{"name": "west_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_3", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_0", "type": "r"}]}]}, {"name": "go/east", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "west_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "free", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}]}, {"name": "take", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "at", "arguments": [{"name": "f_2", "type": "f"}, {"name": "r_2", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_2", "type": "f"}, {"name": "I", "type": "I"}]}]}], "condition": {"name": "trigger", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_2", "type": "f"}, {"name": "I", "type": "I"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_2", "type": "r"}]}, {"name": "in", "arguments": [{"name": "f_2", "type": "f"}, {"name": "I", "type": "I"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "P", "type": "P"}, {"name": "f_1", "type": "f"}, {"name": "r_1", "type": "r"}]}]}}], "fail_events": []}}